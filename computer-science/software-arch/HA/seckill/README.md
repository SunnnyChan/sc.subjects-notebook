# 秒杀 （seckill）

## 策略
* 过载保护
```md
如果检测到系统满负载状态，拒绝请求也是一种保护措施。
将过载保护设置在 CGI 入口层，快速将客户的直接请求返回。
```
## Traps
* 重启 
```md
如果系统发生“雪崩”，贸然重启服务，是无法解决问题的。最常见的现象是，启动起来后，立刻挂掉。
最好在入口层将流量拒绝，然后再进行重启。

如果是 Redis/Memcache 这种服务也挂了，重启的时候需要注意“预热”，并且很可能需要比较长的时间。
```
* 请求伪造
> * 同一个账号，一次性发出多个请求
```md
应对方案：
  在程序入口处，一个账号只允许接受 1 个请求，其他请求过滤。
  不仅解决了同一个账号，发送 N 个请求的问题，还保证了后续的逻辑流程的安全。
  
实现方案：
  可以通过 Redis 这种内存缓存服务，写入一个标志位（只允许 1 个请求写成功，结合 Watch 的乐观锁的特性），
  成功写入的则可以继续参加。
```
> * 多个账号，一次性发送多个请求
```md
应对方案：这种场景，可以通过检测指定机器 IP 请求频率就可以解决。

1. 弹出验证码，最核心的追求，就是分辨出真实用户
2. 直接禁止 IP，实际上是有些粗暴的
```
> * 多个账号，不同 IP 发送不同请求
```md
应对方案：
这种场景下的请求，和真实用户的行为，已经基本相同了，想做分辨很困难。
通常只能通过设置业务门槛高来限制这种请求了，或者通过账号行为的”数据挖掘“来提前清理掉它们。
```
* 数据安全
> * 超发问题
```md
1. 悲观锁思路
2. FIFO 队列思路
3. 乐观锁思路
```
